import pytest
from exojax.spec.profconv import calc_xsection_from_lsd_zeroscan
from exojax.spec.profconv import calc_open_xsection_from_lsd_zeroscan
from exojax.spec.profconv import calc_xsection_from_lsd_scanfft
from exojax.utils.grids import extended_wavenumber_grid
from exojax.utils.grids import wavenumber_grid
import jax.numpy as jnp
import numpy as np
from jax import config


@pytest.mark.parametrize("i", [0, -1])
def test_basic_convolution_calc_xsection_from_lsd_zeroscan(i):
    Nsignal, Ngamma, Slsd = _sld_sample(i)
    # these are used for log-linear conversuion, so assume identical convolution in this test
    R = 1.0
    nu_grid = jnp.ones(Nsignal)
    pmarray = np.ones(len(nu_grid) + 1)
    pmarray[1::2] = pmarray[1::2] * -1.0
    nsigmaD = 1.0
    log_ngammaL_grid = jnp.ones(Ngamma)

    xsv = calc_xsection_from_lsd_zeroscan(
        Slsd, R, pmarray, nsigmaD, nu_grid, log_ngammaL_grid
    )
    xsv_ref = _ref_value_xsv_closed_vkform(i)
    assert jnp.allclose(xsv, xsv_ref)
    return xsv


@pytest.mark.parametrize("i", [0, -1])
def test_agreement_zeroscan_scanfft(i):
    Nsignal, Ngamma, Slsd = _sld_sample(i)
    # these are used for log-linear conversuion, so assume identical convolution in this test
    R = 1.0
    nu_grid = jnp.ones(Nsignal)
    pmarray = np.ones(len(nu_grid) + 1)
    pmarray[1::2] = pmarray[1::2] * -1.0
    nsigmaD = 1.0
    log_ngammaL_grid = jnp.ones(Ngamma)

    xsv = calc_xsection_from_lsd_zeroscan(
        Slsd, R, pmarray, nsigmaD, nu_grid, log_ngammaL_grid
    )
    xsv2 = calc_xsection_from_lsd_scanfft(
        Slsd, R, pmarray, nsigmaD, nu_grid, log_ngammaL_grid
    )
    assert jnp.allclose(xsv, xsv2)


def _sld_sample(i):
    Nsignal = 16
    Ngamma = 2
    Slsd = np.zeros((Nsignal, Ngamma))
    Slsd[i, :] = 1.0
    return Nsignal, Ngamma, Slsd


def _ref_value_xsv_closed_vkform(i):
    """This reference value is based on the closed-form vk (analytic FFT-Voigt from by Dirk van den Bekerom)
    Slightly different from the open-form FFT(LPF Voigt), and doubled by NgammaL=2
    """
    xsv_ref = np.array(
        [
            0.21061051,
            0.19358274,
            0.15388829,
            0.11205564,
            0.07943292,
            0.05703694,
            0.04214784,
            0.03212026,
            0.02517008,
            0.02020074,
            0.01654267,
            0.01377992,
            0.01164654,
            0.00996912,
            0.00864311,
            0.0076811,
        ]
    )
    if i == 0:
        return xsv_ref
    elif i == -1:
        return xsv_ref[::-1]
    else:
        raise ValueError("Invalid i")


def _ref_value_xsv_open_lpffilter(i):
    """This reference value is based on the open-form FFT(LPF Voigt),
    slightly different (0.25%) from the closed-form vk (analytic FFT-Voigt from by Dirk van den Bekerom)
    and doubled by NgammaL=2

    generated by the following code:

    Examples:
        ngammaL_grid = jnp.exp(log_ngammaL_grid)
        vmap_generate_lpffilter = vmap(generate_open_lpffilter, (None, None, 0), 0)
        lpffilter = vmap_generate_lpffilter(filter_length_oneside, nsigmaD, ngammaL_grid)
        lpffilter = jnp.sum(lpffilter, axis=0)

    """
    xsv_ref = np.array(
        [
            0.00754053,
            0.00863053,
            0.00997241,
            0.01164898,
            0.01377942,
            0.01653954,
            0.02019601,
            0.02516528,
            0.03211646,
            0.04214629,
            0.0570379,
            0.07943695,
            0.11206208,
            0.15389713,
            0.19359266,
            0.21062122,
        ]
    )
    if i == 0:
        return xsv_ref
    elif i == -1:
        return xsv_ref[::-1]
    else:
        raise ValueError("Invalid i")


@pytest.mark.parametrize("i", [0, -1])
def test_basic_convolution_calc_open_xsection_from_lsd_zeroscan(i, figure=False):
    config.update("jax_enable_x64", True)
    Nsignal, Ngamma, Slsd = _sld_sample(i)
    # these are used for log-linear conversuion, so assume identical convolution in this test
    R = 1.0
    nu_grid, wav, res = wavenumber_grid(
        22000,
        23000,
        Nsignal,
        unit="AA",
        xsmode="premodit",
        wavelength_order="descending",
    )
    nsigmaD = 1.0
    log_ngammaL_grid = jnp.ones(Ngamma)
    filter_length_oneside = 15
    nu_grid_extended = extended_wavenumber_grid(
        nu_grid, filter_length_oneside, filter_length_oneside
    )
    xsv = calc_open_xsection_from_lsd_zeroscan(
        Slsd, R, nsigmaD, nu_grid_extended, log_ngammaL_grid, filter_length_oneside
    )
    xsv = xsv * nu_grid_extended  # avoid the log conversion
    xsv_ref = _ref_value_xsv_open_lpffilter(i)
    if i == -1:
        res_alias = np.max(
            np.abs(
                xsv[-filter_length_oneside - 1 :]
                / xsv_ref[0 : filter_length_oneside + 1]
                - 1.0
            )
        )
    elif i == 0:
        res_alias = np.max(
            np.abs(
                xsv[0:filter_length_oneside] / xsv_ref[0:filter_length_oneside] - 1.0
            )
        )
    else:
        raise ValueError("Invalid i")
    # print(res_alias)

    assert res_alias < 1.0e-6  # 3.786391858939808e-07

    if figure:
        fig = plt.figure()
        ax = fig.add_subplot(211)
        if i == 0:
            plt.plot(xsv[0:filter_length_oneside], "o", label="xsv")
            plt.plot(xsv_ref[0:filter_length_oneside], "+", label="xsv_ref")
        elif i == -1:
            plt.plot(xsv[-filter_length_oneside - 1 :], "o")
            plt.plot(xsv_ref[0 : filter_length_oneside + 1], "+")
        plt.legend()
        ax = fig.add_subplot(212)
        if i == 0:
            plt.plot(
                xsv[1:filter_length_oneside] / xsv_ref[1:filter_length_oneside] - 1, "."
            )
        elif i == -1:
            plt.plot(
                xsv[-filter_length_oneside - 1 :]
                / xsv_ref[0 : filter_length_oneside + 1]
                - 1,
                "o",
            )
        plt.show()


if __name__ == "__main__":
    import matplotlib.pyplot as plt

    # xsv = test_basic_convolution_calc_xsection_from_lsd_zeroscan(0)
    # xsv = test_basic_convolution_calc_xsection_from_lsd_zeroscan(-1)
    i = -1
    test_basic_convolution_calc_open_xsection_from_lsd_zeroscan(i, figure=True)
