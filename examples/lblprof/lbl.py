from numpyro.diagnostics import hpdi
from numpyro.infer import Predictive
from numpyro.infer import MCMC, NUTS
import numpyro
import numpyro.distributions as dist
from jax import vmap, jit
from jax import random
from exojax.spec import initspec
from exojax.spec import make_numatrix0
from exojax.spec import moldb, contdb
from exojax.spec import rtransfer as rt
from exojax.utils.constants import RJ, pc, Rs, c
from exojax.spec import molinfo
from exojax.spec.lpf import xsvector
from exojax.spec import planck, response
from exojax.spec.rtransfer import rtrun, dtauM, dtauCIA, nugrid
from exojax.spec.hitrancia import read_cia, logacia
from exojax.spec.hitran import SijT, doppler_sigma, gamma_natural, gamma_hitran
from exojax.spec.exomol import gamma_exomol
from exojax.spec.lpf import xsmatrix
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import jax.numpy as jnp

dat = pd.read_csv('../tutorial/spectrum.txt',
                  delimiter=',', names=('wav', 'flux'))
# data generated by Forward modeling.ipynb
wavd = dat['wav'].values
flux = dat['flux'].values
nusd = jnp.array(1.e8/wavd[::-1])
sigmain = 0.05
norm = 40000
nflux = flux/norm+np.random.normal(0, sigmain, len(wavd))


# The model is almost same as the forward modeling, but we will infer here Rp, RV, MMR_CO, T0, alpha, and Vsini.
# In[7]:


NP = 100
Parr, dParr, k = rt.pressure_layer(NP=NP)
Nx = 1500
nus, wav, res = nugrid(np.min(wavd)-5.0, np.max(wavd)+5.0, Nx, unit='AA')

R = 100000.
beta = c/(2.0*np.sqrt(2.0*np.log(2.0))*R)

molmassCO = molinfo.molmass('CO')
mmw = 2.33  # mean molecular weight
mmrH2 = 0.74
molmassH2 = molinfo.molmass('H2')
vmrH2 = (mmrH2*mmw/molmassH2)  # VMR

Mp = 33.2  # fixing mass...

# Loading the molecular database of CO and the CIA
# In[8]:


mdbCO = moldb.MdbExomol('.database/CO/12C-16O/Li2015', nus, crit=1.e-46)
cdbH2H2 = contdb.CdbCIA('.database/H2-H2_2011.cia', nus)


# We have only 39 CO lines.
# Again, numatrix should be precomputed prior to HMC-NUTS.


numatrix_CO = make_numatrix0(nus, mdbCO.nu_lines)

# Or you can use initspec.init_lpf instead.
numatrix_CO = initspec.init_lpf(mdbCO.nu_lines, nus)

# reference pressure for a T-P model
Pref = 1.0  # bar
ONEARR = np.ones_like(Parr)
ONEWAV = jnp.ones_like(nflux)


# In[14]:


smalla = 1.0
smalldiag = smalla**2*jnp.identity(NP)


# Now we write the model, which is used in HMC-NUTS.

# In[15]:


def modelcov(t, tau, a):
    fac = 1.e-5
    Dt = t - jnp.array([t]).T
    amp = a
    K = amp*jnp.exp(-(Dt)**2/2/(tau**2))+amp*fac*jnp.identity(NP)
    return K


# In[16]:


ZEROARR = jnp.zeros_like(Parr)
lnParr = jnp.log10(Parr)


# In[17]:


def model_c(nu1, y1):
    Rp = numpyro.sample('Rp', dist.Uniform(0.4, 1.2))
    RV = numpyro.sample('RV', dist.Uniform(5.0, 15.0))
    MMR_CO = numpyro.sample('MMR_CO', dist.Uniform(0.0, 0.015))
    vsini = numpyro.sample('vsini', dist.Uniform(15.0, 25.0))
    g = 2478.57730044555*Mp/Rp**2  # gravity
    u1 = 0.0
    u2 = 0.0

    # Layer-by-layer T-P model//
    lnsT = 6.0
#    lnsT = numpyro.sample('lnsT', dist.Uniform(3.0,5.0))
    sT = 10**lnsT
    lntaup = 0.5
#    lntaup =  numpyro.sample('lntaup', dist.Uniform(0,1))
    taup = 10**lntaup
    cov = modelcov(lnParr, taup, sT)

#    T0=numpyro.sample('T0', dist.Uniform(1000.0,1100.0))
    T0 = numpyro.sample('T0', dist.Uniform(1000, 2000))
    Tarr = numpyro.sample('Tarr', dist.MultivariateNormal(
        loc=ONEARR, covariance_matrix=cov))+T0
    # line computation CO
    qt_CO = vmap(mdbCO.qr_interp)(Tarr)

    def obyo(y, tag, nusd, nus, numatrix_CO, mdbCO, cdbH2H2):
        # CO
        SijM_CO = jit(vmap(SijT, (0, None, None, None, 0)))(
            Tarr, mdbCO.logsij0, mdbCO.dev_nu_lines, mdbCO.elower, qt_CO)
        gammaLMP_CO = jit(vmap(gamma_exomol, (0, 0, None, None)))(
            Parr, Tarr, mdbCO.n_Texp, mdbCO.alpha_ref)
        gammaLMN_CO = gamma_natural(mdbCO.A)
        gammaLM_CO = gammaLMP_CO+gammaLMN_CO[None, :]

        sigmaDM_CO = jit(vmap(doppler_sigma, (None, 0, None)))(
            mdbCO.dev_nu_lines, Tarr, molmassCO)
        xsm_CO = xsmatrix(numatrix_CO, sigmaDM_CO, gammaLM_CO, SijM_CO)
        dtaumCO = dtauM(dParr, xsm_CO, MMR_CO*ONEARR, molmassCO, g)
        # CIA
        dtaucH2H2 = dtauCIA(nus, Tarr, Parr, dParr, vmrH2, vmrH2,
                            mmw, g, cdbH2H2.nucia, cdbH2H2.tcia, cdbH2H2.logac)
        dtau = dtaumCO+dtaucH2H2
        sourcef = planck.piBarr(Tarr, nus)
        F0 = rtrun(dtau, sourcef)/norm

        Frot = response.rigidrot(nus, F0, vsini, u1, u2)
        mu = response.ipgauss_sampling(nusd, nus, Frot, beta, RV)
        numpyro.sample(tag, dist.Normal(mu, sigmain), obs=y)

    obyo(y1, 'y1', nu1, nus, numatrix_CO, mdbCO, cdbH2H2)


# Run a HMC-NUTS. It took ~30min using my gaming laptop (GTX 1080 Max-Q). Here, the number of warmup is only 300, and that of the sampling is only 600, because the time when the draft on arxiv will be released is very soon (June 1st 2021 morning in JST!).

# In[ ]:


rng_key = random.PRNGKey(0)
rng_key, rng_key_ = random.split(rng_key)
num_warmup, num_samples = 500, 1000
kernel = NUTS(model_c, forward_mode_differentiation=True, max_tree_depth=16)
mcmc = MCMC(kernel, num_warmup=num_warmup, num_samples=num_samples)
mcmc.run(rng_key_, nu1=nusd, y1=nflux)

# Post-processing
posterior_sample = mcmc.get_samples()
np.savez('npz/savepos.npz', [posterior_sample])
# posterior_sample=np.load("npz/savepos.npz",allow_pickle=True)["arr_0"][0]

pred = Predictive(model_c, posterior_sample, return_sites=['y1'])
nu_1 = nusd
predictions = pred(rng_key_, nu1=nu_1, y1=None)
median_mu1 = jnp.median(predictions['y1'], axis=0)
hpdi_mu1 = hpdi(predictions['y1'], 0.9)
np.savez('npz/saveplotpred.npz', [nusd, nflux, median_mu1, hpdi_mu1])
